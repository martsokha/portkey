//! Chat completion models for the Portkey API.
//!
//! This module contains all data models for chat completions, including
//! request and response types following the OpenAI-compatible format.

use serde::{Deserialize, Serialize};
#[cfg(feature = "strum")]
use strum::{Display, EnumString};

/// A chat completion message in a conversation.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "role", rename_all = "lowercase")]
pub enum ChatCompletionRequestMessage {
    /// System message that sets the behavior of the assistant
    System {
        /// The contents of the system message
        content: String,
        /// Optional name for the participant
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    /// Developer message (new role by OpenAI for select models)
    Developer {
        /// The contents of the developer message
        content: String,
        /// Optional name for the participant
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    /// User message in the conversation
    User {
        /// The contents of the user message (text or array of content parts)
        content: ChatCompletionUserMessageContent,
        /// Optional name for the participant
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    /// Assistant message in the conversation
    Assistant {
        /// The contents of the assistant message
        #[serde(skip_serializing_if = "Option::is_none")]
        content: Option<String>,
        /// Optional name for the participant
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        /// Tool calls generated by the model
        #[serde(skip_serializing_if = "Option::is_none")]
        tool_calls: Option<Vec<ChatCompletionMessageToolCall>>,
        /// Deprecated: Function call (use tool_calls instead)
        #[serde(skip_serializing_if = "Option::is_none")]
        function_call: Option<FunctionCall>,
    },
    /// Tool response message
    Tool {
        /// The contents of the tool message
        content: String,
        /// Tool call ID that this message is responding to
        tool_call_id: String,
    },
    /// Function response message (deprecated)
    Function {
        /// The contents of the function message
        content: String,
        /// The name of the function
        name: String,
    },
}

impl ChatCompletionRequestMessage {
    /// Creates a system message.
    ///
    /// # Example
    ///
    /// ```
    /// use portkey_sdk::model::ChatCompletionRequestMessage;
    ///
    /// let msg = ChatCompletionRequestMessage::system("You are a helpful assistant.");
    /// ```
    pub fn system(content: impl Into<String>) -> Self {
        Self::System {
            content: content.into(),
            name: None,
        }
    }

    /// Creates a user message with text content.
    ///
    /// # Example
    ///
    /// ```
    /// use portkey_sdk::model::ChatCompletionRequestMessage;
    ///
    /// let msg = ChatCompletionRequestMessage::user("Hello!");
    /// ```
    pub fn user(content: impl Into<String>) -> Self {
        Self::User {
            content: ChatCompletionUserMessageContent::Text(content.into()),
            name: None,
        }
    }

    /// Creates an assistant message.
    ///
    /// # Example
    ///
    /// ```
    /// use portkey_sdk::model::ChatCompletionRequestMessage;
    ///
    /// let msg = ChatCompletionRequestMessage::assistant("Hello! How can I help you?");
    /// ```
    pub fn assistant(content: impl Into<String>) -> Self {
        Self::Assistant {
            content: Some(content.into()),
            name: None,
            tool_calls: None,
            function_call: None,
        }
    }
}

/// Content of a user message (can be text or multimodal)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatCompletionUserMessageContent {
    /// Plain text content
    Text(String),
    /// Array of content parts (text and/or images)
    Parts(Vec<ChatCompletionContentPart>),
}

/// A content part in a multimodal message
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ChatCompletionContentPart {
    /// Text content part
    Text {
        /// The text content
        text: String,
    },
    /// Image URL content part
    ImageUrl {
        /// Image URL or base64 encoded image data
        image_url: ImageUrl,
    },
}

/// Image URL configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageUrl {
    /// URL of the image or base64 encoded image data
    pub url: String,
    /// Detail level of the image (auto, low, or high)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<ImageDetail>,
}

/// Image detail level for vision models
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[cfg_attr(feature = "strum", derive(Display, EnumString))]
#[serde(rename_all = "lowercase")]
#[cfg_attr(feature = "strum", strum(serialize_all = "lowercase"))]
pub enum ImageDetail {
    /// Auto detail level (default)
    #[default]
    Auto,
    /// Low detail level
    Low,
    /// High detail level
    High,
}

/// Function call information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    /// The name of the function to call
    pub name: String,
    /// The arguments to call the function with (JSON format)
    pub arguments: String,
}

/// Tool call made by the model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatCompletionMessageToolCall {
    /// The ID of the tool call
    pub id: String,
    /// The type of tool (currently only "function")
    #[serde(rename = "type")]
    pub tool_type: String,
    /// The function to call
    pub function: FunctionCall,
}

/// Response format configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ResponseFormat {
    /// Text response format (default)
    Text,
    /// JSON object response format
    JsonObject,
    /// JSON schema response format (Structured Outputs)
    JsonSchema {
        /// JSON schema configuration
        json_schema: JsonSchema,
    },
}

impl ResponseFormat {
    /// Creates a JSON schema from a type implementing `schemars::JsonSchema`.
    ///
    /// Returns a `JsonSchema` that can be used directly or customized with builder methods.
    /// To use with `ResponseFormat`, wrap in `ResponseFormat::JsonSchema { json_schema: ... }`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use schemars::JsonSchema;
    /// use serde::{Deserialize, Serialize};
    /// use portkey_sdk::model::ResponseFormat;
    ///
    /// #[derive(Serialize, Deserialize, JsonSchema)]
    /// struct MyResponse {
    ///     message: String,
    ///     count: i32,
    /// }
    ///
    /// let response_format = ResponseFormat::JsonSchema {
    ///     json_schema: ResponseFormat::json_schema::<MyResponse>()
    ///         .with_description("A custom response structure")
    ///         .with_strict(true),
    /// };
    /// ```
    #[cfg(feature = "schema")]
    #[cfg_attr(docsrs, doc(cfg(feature = "schema")))]
    pub fn json_schema<T>() -> JsonSchema
    where
        T: schemars::JsonSchema,
    {
        JsonSchema::from_type::<T>()
    }
}

/// JSON Schema configuration for Structured Outputs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonSchema {
    /// A description of what the response format is for
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The name of the response format
    pub name: String,
    /// The JSON Schema object
    pub schema: serde_json::Value,
    /// Whether to enable strict schema adherence
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
}

impl JsonSchema {
    /// Creates a new JSON schema configuration from a type implementing `schemars::JsonSchema`.
    ///
    /// Uses the type's fully qualified name as the default name. Use builder methods
    /// `with_name()`, `with_description()`, and `with_strict()` to customize.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use schemars::JsonSchema;
    /// use serde::{Deserialize, Serialize};
    /// use portkey_sdk::model::JsonSchema as PortkeyJsonSchema;
    ///
    /// #[derive(Serialize, Deserialize, JsonSchema)]
    /// struct MyResponse {
    ///     message: String,
    ///     count: i32,
    /// }
    ///
    /// let schema = PortkeyJsonSchema::from_type::<MyResponse>()
    ///     .with_name("MyResponse")
    ///     .with_description("A custom response structure")
    ///     .with_strict(true);
    /// ```
    #[cfg(feature = "schema")]
    #[cfg_attr(docsrs, doc(cfg(feature = "schema")))]
    pub fn from_type<T>() -> Self
    where
        T: schemars::JsonSchema,
    {
        let schema_obj = schemars::schema_for!(T);
        let type_name = std::any::type_name::<T>();
        let name = type_name.split("::").last().unwrap_or(type_name);

        Self {
            description: None,
            name: name.to_string(),
            schema: serde_json::to_value(schema_obj).expect("Failed to serialize schema"),
            strict: None,
        }
    }

    /// Sets the name for this JSON schema.
    #[cfg(feature = "schema")]
    #[cfg_attr(docsrs, doc(cfg(feature = "schema")))]
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }

    /// Sets the description for this JSON schema.
    #[cfg(feature = "schema")]
    #[cfg_attr(docsrs, doc(cfg(feature = "schema")))]
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Sets whether to enable strict schema adherence.
    #[cfg(feature = "schema")]
    #[cfg_attr(docsrs, doc(cfg(feature = "schema")))]
    pub fn with_strict(mut self, strict: bool) -> Self {
        self.strict = Some(strict);
        self
    }
}

/// Stream options for streaming responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StreamOptions {
    /// If set, include usage information in the final chunk
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_usage: Option<bool>,
}

/// Thinking mode configuration for Claude models
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThinkingConfig {
    /// Type of thinking mode (enabled or disabled)
    #[serde(rename = "type")]
    pub thinking_type: ThinkingType,
    /// Maximum number of tokens to allocate for thinking
    #[serde(skip_serializing_if = "Option::is_none")]
    pub budget_tokens: Option<i32>,
}

/// Thinking mode type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[cfg_attr(feature = "strum", derive(Display, EnumString))]
#[serde(rename_all = "lowercase")]
#[cfg_attr(feature = "strum", strum(serialize_all = "lowercase"))]
pub enum ThinkingType {
    /// Thinking mode enabled
    Enabled,
    /// Thinking mode disabled
    Disabled,
}

/// Function definition for function calling
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionObject {
    /// The name of the function
    pub name: String,
    /// A description of what the function does
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The parameters the function accepts (JSON Schema)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    /// Whether to enable strict schema adherence
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
}

/// Tool definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tool {
    /// The type of tool (currently only "function")
    #[serde(rename = "type")]
    pub tool_type: String,
    /// The function definition
    pub function: FunctionObject,
}

/// Tool choice option
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolChoice {
    /// Simple string choice (none, auto, required)
    Simple(ToolChoiceSimple),
    /// Named tool choice
    Named(NamedToolChoice),
}

/// Simple tool choice options
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[cfg_attr(feature = "strum", derive(Display, EnumString))]
#[serde(rename_all = "lowercase")]
#[cfg_attr(feature = "strum", strum(serialize_all = "lowercase"))]
pub enum ToolChoiceSimple {
    /// No tool will be called
    None,
    /// Model can choose to call a tool or not
    Auto,
    /// Model must call one or more tools
    Required,
}

/// Named tool choice to force a specific tool
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NamedToolChoice {
    /// The type of tool
    #[serde(rename = "type")]
    pub tool_type: String,
    /// The function to call
    pub function: NamedFunction,
}

/// Named function for tool choice
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NamedFunction {
    /// The name of the function to call
    pub name: String,
}

/// Chat completion request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatCompletionRequest {
    /// ID of the model to use
    pub model: String,
    /// A list of messages comprising the conversation
    pub messages: Vec<ChatCompletionRequestMessage>,
    /// Number between -2.0 and 2.0 for frequency penalty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency_penalty: Option<f32>,
    /// Modify the likelihood of specified tokens
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logit_bias: Option<serde_json::Map<String, serde_json::Value>>,
    /// Whether to return log probabilities
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logprobs: Option<bool>,
    /// Number of most likely tokens to return at each position
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_logprobs: Option<i32>,
    /// Maximum number of tokens to generate
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_tokens: Option<i32>,
    /// How many chat completion choices to generate
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n: Option<i32>,
    /// Number between -2.0 and 2.0 for presence penalty
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_penalty: Option<f32>,
    /// Response format configuration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response_format: Option<ResponseFormat>,
    /// Seed for deterministic sampling
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seed: Option<i64>,
    /// Stop sequences
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop: Option<Stop>,
    /// Whether to stream the response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream: Option<bool>,
    /// Stream options
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_options: Option<StreamOptions>,
    /// Thinking mode configuration (Claude models)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking: Option<ThinkingConfig>,
    /// Sampling temperature (0-2)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f32>,
    /// Nucleus sampling parameter (0-1)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f32>,
    /// List of tools the model may call
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<Tool>>,
    /// Controls which tool is called
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_choice: Option<ToolChoice>,
    /// Whether to enable parallel tool calls
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parallel_tool_calls: Option<bool>,
    /// A unique identifier for the end-user
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

impl ChatCompletionRequest {
    /// Creates a new chat completion request with the minimum required fields.
    ///
    /// # Arguments
    ///
    /// * `model` - The model ID to use (e.g., "gpt-4o", "claude-3-5-sonnet-20241022")
    /// * `messages` - The conversation messages
    ///
    /// # Example
    ///
    /// ```
    /// use portkey_sdk::model::{ChatCompletionRequest, ChatCompletionRequestMessage};
    ///
    /// let request = ChatCompletionRequest::new(
    ///     "gpt-4o",
    ///     vec![
    ///         ChatCompletionRequestMessage::user("Hello!"),
    ///     ],
    /// );
    /// ```
    pub fn new(model: impl Into<String>, messages: Vec<ChatCompletionRequestMessage>) -> Self {
        Self {
            model: model.into(),
            messages,
            frequency_penalty: None,
            logit_bias: None,
            logprobs: None,
            top_logprobs: None,
            max_tokens: None,
            n: None,
            presence_penalty: None,
            response_format: None,
            seed: None,
            stop: None,
            stream: None,
            stream_options: None,
            thinking: None,
            temperature: None,
            top_p: None,
            tools: None,
            tool_choice: None,
            parallel_tool_calls: None,
            user: None,
        }
    }
}

/// Stop sequences (can be a string or array of strings)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Stop {
    /// Single stop sequence
    Single(String),
    /// Multiple stop sequences
    Multiple(Vec<String>),
}

/// Chat completion response message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatCompletionResponseMessage {
    /// The role of the message author
    pub role: String,
    /// The contents of the message
    pub content: Option<String>,
    /// Tool calls made by the model
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ChatCompletionMessageToolCall>>,
    /// Deprecated: Function call (use tool_calls instead)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_call: Option<FunctionCall>,
    /// Content blocks (for providers with strict_openai_compliance=false)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_blocks: Option<Vec<ContentBlock>>,
}

impl ChatCompletionResponseMessage {
    /// Deserializes the JSON content of the message into a custom type.
    ///
    /// This is useful when using structured outputs with JSON schema,
    /// allowing you to deserialize the response into your custom type.
    ///
    /// Returns `Ok(None)` if the message has no content, `Ok(Some(T))` if deserialization succeeds,
    /// or `Err` if the content is not valid JSON for the target type.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use serde::{Deserialize, Serialize};
    ///
    /// #[derive(Serialize, Deserialize)]
    /// struct MyResponse {
    ///     message: String,
    ///     count: i32,
    /// }
    ///
    /// let response_message = /* ... get from API response ... */;
    /// if let Some(parsed) = response_message.deserialize_content::<MyResponse>()? {
    ///     println!("Message: {}, Count: {}", parsed.message, parsed.count);
    /// }
    /// ```
    pub fn deserialize_content<T>(&self) -> crate::Result<Option<T>>
    where
        T: serde::de::DeserializeOwned,
    {
        match &self.content {
            Some(content) => Ok(Some(serde_json::from_str(content)?)),
            None => Ok(None),
        }
    }

    /// Deserializes JSON from markdown code blocks within the message content.
    ///
    /// This method searches for markdown code blocks (` ```json` or ` ``` `) within the content
    /// and extracts the JSON from within them. It can handle content that has text before or
    /// after the code block. If no code block is found, it attempts to parse the entire content.
    ///
    /// Returns `Ok(None)` if the message has no content, `Ok(Some(T))` if deserialization succeeds,
    /// or `Err` if the content is not valid JSON for the target type.
    ///
    /// # Example
    ///
    /// ```ignore
    /// use serde::{Deserialize, Serialize};
    ///
    /// #[derive(Serialize, Deserialize)]
    /// struct MyResponse {
    ///     message: String,
    ///     count: i32,
    /// }
    ///
    /// // Content might be: "Here's your data:\n```json\n{\"message\": \"Hello\", \"count\": 42}\n```\nEnjoy!"
    /// let response_message = /* ... get from API response ... */;
    /// if let Some(parsed) = response_message.deserialize_markdown::<MyResponse>()? {
    ///     println!("Message: {}, Count: {}", parsed.message, parsed.count);
    /// }
    /// ```
    pub fn deserialize_markdown<T>(&self) -> crate::Result<Option<T>>
    where
        T: serde::de::DeserializeOwned,
    {
        match &self.content {
            Some(content) => {
                // Try to find a markdown code block with ```json or ```
                let json_content = if let Some(start_json) = content.find("```json") {
                    // Found ```json, extract content between ```json and closing ```
                    let after_start = &content[start_json + 7..]; // Skip "```json"
                    if let Some(end) = after_start.find("```") {
                        after_start[..end].trim()
                    } else {
                        // No closing ```, use everything after ```json
                        after_start.trim()
                    }
                } else if let Some(start) = content.find("```") {
                    // Found plain ```, extract content between ``` and closing ```
                    let after_start = &content[start + 3..]; // Skip "```"
                    if let Some(end) = after_start.find("```") {
                        after_start[..end].trim()
                    } else {
                        // No closing ```, use everything after ```
                        after_start.trim()
                    }
                } else {
                    // No markdown code block found, try to parse the entire content
                    content.trim()
                };

                Ok(Some(serde_json::from_str(json_content)?))
            }
            None => Ok(None),
        }
    }
}

/// Content block in a response message
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentBlock {
    /// Text content block
    Text {
        /// The text content
        text: String,
    },
    /// Thinking content block
    Thinking {
        /// The thinking content
        thinking: String,
    },
    /// Redacted thinking content block
    RedactedThinking {
        /// The redacted thinking data
        data: String,
    },
}

/// Token log probability information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenLogprob {
    /// The token
    pub token: String,
    /// Log probability of the token
    pub logprob: f64,
    /// UTF-8 bytes representation of the token
    pub bytes: Option<Vec<i32>>,
    /// Top log probabilities at this position
    pub top_logprobs: Vec<TopLogprob>,
}

/// Top token log probability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopLogprob {
    /// The token
    pub token: String,
    /// Log probability of the token
    pub logprob: f64,
    /// UTF-8 bytes representation of the token
    pub bytes: Option<Vec<i32>>,
}

/// Log probability information for a choice
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Logprobs {
    /// List of message content tokens with log probability information
    pub content: Option<Vec<TokenLogprob>>,
}

/// A chat completion choice
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatCompletionChoice {
    /// The reason the model stopped generating tokens
    pub finish_reason: String,
    /// The index of this choice
    pub index: i32,
    /// The completion message
    pub message: ChatCompletionResponseMessage,
    /// Log probability information
    pub logprobs: Option<Logprobs>,
}

/// Token usage statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Usage {
    /// Number of tokens in the prompt
    pub prompt_tokens: i32,
    /// Number of tokens in the completion
    pub completion_tokens: i32,
    /// Total number of tokens used
    pub total_tokens: i32,
}

/// Chat completion response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatCompletionResponse {
    /// A unique identifier for the chat completion
    pub id: String,
    /// The object type (always "chat.completion")
    pub object: String,
    /// The Unix timestamp when the completion was created
    pub created: i64,
    /// The model used for the chat completion
    pub model: String,
    /// A list of chat completion choices
    pub choices: Vec<ChatCompletionChoice>,
    /// Usage statistics
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<Usage>,
    /// System fingerprint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_fingerprint: Option<String>,
}
